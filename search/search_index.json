{"docs":[{"location":"/index.html","text":"Warning This site is still a work in progress #1. Until migration is complete, refer to: Atlas Documentation Spectator Documentation","title":"Atlas"},{"location":"/index.html#atlas","text":"In-memory dimensional time series database.","title":"Atlas"},{"location":"/tutorial.html","text":"","title":"Stack Language Tutorial"},{"location":"/tutorial.html#stack-language-tutorial","text":"name,\nsps,\n:eq,\n(,\nnf.cluster,\n),\n:by","title":"Stack Language Tutorial"},{"location":"/reference/index.html","text":"","title":"Stack Language Reference"},{"location":"/reference/index.html#stack-language-reference","text":"","title":"Stack Language Reference"},{"location":"/reference/query/index.html","text":"","title":"Query"},{"location":"/reference/query/index.html#query","text":"Query expression used to select a set of time series. For more information see the stack language tutorial.","title":"Query"},{"location":"/reference/query/and.html","text":"","title":"and"},{"location":"/reference/query/and.html#and","text":"","title":"and"},{"location":"/reference/and.html","text":"","title":"and"},{"location":"/reference/and.html#and","text":"There are two overloaded variants of the :and operator:\nQuery variant that is used to help restrict the set of time series used for an expression. Math variant that is used to combine to signal time series.","title":"and"},{"location":"/reference/dist-avg.html","text":"","title":"dist-avg"},{"location":"/reference/dist-avg.html#dist-avg","text":"","title":"dist-avg"},{"location":"/reference/dist-avg.html#signature","text":"Query -- TimeSeriesExpr","title":"Signature"},{"location":"/reference/dist-avg.html#summary","text":"Compute standard deviation for timers and distribution summaries.","title":"Summary"},{"location":"/reference/dist-avg.html#examples","text":"","title":"Examples"},{"location":"/reference/dist-avg.html#name-playback-startlatency-eq-dist-stddev","text":"Pos Input Output 0","title":"name,playback.startLatency,:eq,:dist-stddev"},{"location":"/reference/math-and.html","text":"","title":"and"},{"location":"/reference/math-and.html#and","text":"This is a sample graph:","title":"and"},{"location":"/spectator/index.html","text":"","title":"Spectator"},{"location":"/spectator/index.html#spectator","text":"Atlas client library.","title":"Spectator"},{"location":"/spectator/timers.html","text":"","title":"Timers"},{"location":"/spectator/timers.html#timers","text":"A timer is used to measure how long some event is taking. Two types of timers are supported:\nTimer: for frequent short duration events. LongTaskTimer: for long running tasks.\nThe long duration timer is setup so that you can track the time while an event being measured is still running. A regular timer just records the duration and has no information until the task is complete.\nAs an example, consider a chart showing request latency to a typical web server. The expectation is many short requests so the timer will be getting updated many times per second.\nNow consider a background process to refresh metadata from a data store. For example, Edda caches AWS resources such as instances, volumes, auto-scaling groups etc. Normally all data can be refreshed in a few minutes. If the AWS services are having problems it can take much longer. A long duration timer can be used to track the overall time for refreshing the metadata.\nThe charts below show max latency for the refresh using a regular timer and a long task timer. Regular timer, note that the y-axis is using a logarithmic scale:\nLong task timer:","title":"Timers"},{"location":"/spectator/timers.html#timer","text":"To get started create an instance using the registry:\nJava public class TimerExample {\n\n  private final Registry registry;\n  private final Timer requestLatency;\n\n  @Inject\n  public TimerExample(Registry registry) {\n    this.registry = registry;\n    requestLatency = registry.timer(\"server.requestLatency\");\n  } Python class TimerExample:\n\n    def __init__(self, registry=GlobalRegistry):\n        self._registry = registry\n        self._requestLatency = registry.timer('server.requestLatency')\nThen wrap the call you need to measure, preferably using a lambdaa with statement:\nJava public Response handleUsingLambda(Request request) throws Exception {\n  return requestLatency.record(() -> handleImpl(request));\n} Python def handle_using_with(self, request):\n    with self._requestLatency.stopwatch():\n        return self._handle_impl(request)\nThe lambda variants will handle exceptions for you and ensure the record happens as part of a finally block using the monotonic time. It could also have been done more explicitly like:\nJava public Response handleExplicitly(Request request) {\n  final long start = registry.clock().monotonicTime();\n  try {\n    return handleImpl(request);\n  } finally {\n    final long end = registry.clock().monotonicTime();\n    requestLatency.record(end - start, TimeUnit.NANOSECONDS);\n  }\n} Python def handle_explicitly(self, request):\n    start = self._registry.clock().monotonic_time()\n    try:\n        return self._handle_impl(request)\n    finally:\n        end = self._registry.clock().monotonic_time()\n        self._requestLatency.record(end - start)\nThis example uses the clock from the registry which can be useful for testing if you need to control the timing. In actual usage it will typically get mapped to the system clock. It is recommended to use a monotonically increasing source for measuring the times to avoid occasionally having bogus measurements due to time adjustments. For more information see the Clock documentation.","title":"Timer"},{"location":"/spectator/timers.html#longtasktimer","text":"To get started create an instance using the registry:\npublic class MetadataService {\n\n  private final LongTaskTimer metadataRefresh;\n\n  @Inject\n  public MetadataService(Registry registry) {\n    metadataRefresh = registry.longTaskTimer(\"metadata.refreshDuration\");\n    // setup background thread to call refresh()\n  }\n\n  private void refresh() {\n    final int id = metadataRefresh.start();\n    try {\n      refreshImpl();\n    } finally {\n      metadataRefresh.stop(id);\n    }\n  }\nThe id is used to keep track of a particular task being measured by the timer. It must be stopped using the provided id. Note that unlike a regular timer that does not do anything until the final duration is recorded, a long duration timer will report as two gauges:\nduration: total duration spent within all currently running tasks. activeTasks: number of currently running tasks.\nThis means that you can see what is happening while the task is running, but you need to keep in mind:\nThe id is fixed before the task begins. There is no way to change tags based on the run, e.g., update a different timer if an exception is thrown. Being a guage it is inappropriate for short tasks. In particular, gauges are sampled and if it is not sampled during the execution or the sampling period is a significant subset of the expected duration, then the duration value will not be meaningful.\nLike a regular timer, the duration timer also supports using a lambda to simplify the common case:\nprivate void refresh() {\n    metadataRefresh.record(this::refreshImpl);\n  }","title":"LongTaskTimer"},{"location":"/spectator/netflix.html","text":"","title":"Netflix Integration"},{"location":"/spectator/netflix.html#netflix-integration","text":"When running at Netflix, use the atlas-client library to enable transferring the instrumented data to Atlas. See the appropriate section for the type of project you are working on: Libraries Applications, specifically standalone apps using guice or governator directly. Base Server Libraries For libraries, the only dependency that should be needed is: com.netflix.spectator:spectator-api:0.62.0\n The bindings to integrate internally should be included with the application. In your code, just inject a registry, e.g.: public class Foo {\n  @Inject\n  public Foo(Registry registry) {\n    ...\n  }\n  ...\n}\n See the testing docs for more information about creating a binding to use with tests. Libraries should not install SpectatorModule. The bindings to use for the registry should be determined by the application that is using the library. Think of it as being like slf4j where logging configuration is up to the end-user, not the library owner. When creating a Guice module for your library, you may want to avoid binding errors if the end-user has not provided a binding for the Spectator registry. This can be done by using optional injections inside of the module, for example: // Sample library class\npublic class MyLib {\n  Registry registry;\n\n  @Inject\n  public MyLib(Registry registry) {\n    this.registry = registry;\n  }\n}\n\n// Guice module to configure the library and setup the bindings\npublic class MyLibModule extends AbstractModule {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(MyLibModule.class);\n\n  @Override\n  protected void configure() {\n  }\n\n  @Provides\n  private MyLib provideMyLib(OptionalInjections opts) {\n    return new MyLib(opts.registry());\n  }\n\n  private static class OptionalInjections {\n    @Inject(optional = true)\n    private Registry registry;\n\n    Registry registry() {\n      if (registry == null) {\n        LOGGER.warn(\"no spectator registry has been bound, so using noop implementation\");\n        registry = new NoopRegistry();\n      }\n      return registry;\n    }\n  }\n}\n Applications Application should include a dependency on the atlas-client plugin: netflix:atlas-client:latest.release\n Note this is an internal only library with configs specific to the Netflix environments. It is assumed you are using Nebula so that internal maven repositories are available for your build. When configuring with governator specify the AtlasModule: Injector injector = LifecycleInjector.builder()\n    .withModules(new AtlasModule())\n    .build()\n    .createInjector();\n The registry binding will then be available so it can be injected as shown in the libraries section. The insight libraries do not use any governator or guice specific features. So it is possible to use guice or other dependency injection frameworks directly with the following caveats: However, some of the libraries do use the @PostConstruct and @PreDestroy annotations for managing lifecycle. Governator adds lifecycle management and many other features on top of guice and is the recommended way. For more minimalist support of just the lifecycle annotations on top of guice see iep-guice. The bindings and configuration necessary to run correctly with the internal setup are only supported as guice modules. If trying to use some other dependency injection framework, then you will be responsible for either finding a way to leverage the guice module in that framework or recreating those bindings and maintaining them as things change. It is not a paved road path. Base Server If using base-server, then you will get the Spectator and Atlas bindings automatically. Auto Plugin\nWarning Deprecated: Use of AutoBindSingleton is generally discouraged. It is recommended to use one of the other methods.\nIf you are only interested in getting the GC logging, there is a library with an auto-bind singleton that can be used: com.netflix.spectator:spectator-nflx:0.62.0\n Assuming you are using karyon/base-server or governator with com.netflix in the list of base packages then the plugin should get automatically loaded.\nWhen running at Netflix, use the nflx-spectator-config library to enable transferring the instrumented data to Atlas. See the appropriate section for the type of project you are working on: Libraries Applications Winston Libraries Libraries should use the open source library directly and allow the application to determine how it is configured. pip install netflix-spectator-py\n Applications Should include a dependency on nflx-spectator-config to get the right settings for publishing internally. Winston If using Winston, then you will get the Spectator and Atlas bindings automatically.","title":"Netflix Integration"}]}